<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Design Patterns</title>
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#ffffff">
    <style>
        /* Reset e Stili di Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Stili del corpo con gradiente e font moderno */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
        }

        /* Contenitore principale */
        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header del quiz */
        .header {
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative; /* Per posizionare la freccia di ritorno */
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #cbd5e1;
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: white;
        }

        /* Sezione della barra di progresso */
        .progress-section {
            padding: 30px 40px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            transition: opacity 0.3s ease-in-out;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5, #06b6d4);
            width: 0%;
            transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            border-radius: 4px;
        }

        .progress-text {
            font-weight: 600;
            color: #475569;
        }

        /* Contenuto del quiz (domande) */
        .quiz-content {
            padding: 40px;
            flex-grow: 1;
            transition: opacity 0.3s ease-in-out;
        }

        /* Card della singola domanda */
        .question-card {
            background: white;
            border-radius: 16px;
            padding: 35px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border: 1px solid #f1f5f9;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .pattern-category, .question-type {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
        }

        /* Colori per le categorie */
        .grasp { background: linear-gradient(135deg, #10b981, #059669); }
        .gof-creational { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .gof-structural { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .gof-behavioral { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }

        .question-text {
            font-size: 1.15rem;
            line-height: 1.6;
            color: #1e293b;
            margin-bottom: 25px;
            font-weight: 500;
        }

        /* Opzioni di risposta */
        .options {
            display: grid;
            gap: 15px;
            margin-bottom: 25px;
        }

        .option {
            padding: 15px 25px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-align: left;
            color: #374151;
        }

        .option:not(.selected):not(.correct):not(.incorrect):hover {
            border-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.1);
        }

        .option.selected {
            border-color: #4f46e5;
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.2);
        }

        .option.correct {
            border-color: #10b981;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .option.incorrect {
            border-color: #ef4444;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .option.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Spiegazione della risposta */
        .explanation {
            margin-top: 25px;
            padding: 20px;
            background: #f1f5f9;
            border-radius: 10px;
            border-left: 4px solid #4f46e5;
            animation: fadeIn 0.5s 0.2s forwards;
        }
        .explanation h4 { color: #4f46e5; margin-bottom: 10px; }
        .explanation p { color: #475569; line-height: 1.6; }

        /* Controlli di navigazione */
        .controls {
            padding: 30px 40px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: linear-gradient(135deg, #4f46e5, #06b6d4); color: white; }
        .btn-secondary { background: #e2e8f0; color: #475569; }

        .current-stats {
            display: flex;
            gap: 20px;
            font-weight: 600;
            color: #475569;
            flex-grow: 1;
            justify-content: center;
        }
        .current-stats .correct-count { color: #10b981; }
        .current-stats .incorrect-count { color: #ef4444; }

        /* Sezione dei risultati */
        .results { text-align: center; padding: 60px 40px; }
        .score-circle { width: 150px; height: 150px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 30px; }
        .score-inner { width: 120px; height: 120px; background: white; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .score-percentage { font-size: 2.2rem; font-weight: 700; color: #4f46e5; }
        .score-label { font-size: 0.9rem; color: #6b7280; margin-top: 5px; }
        .results h2 { font-size: 2rem; color: #1e293b; margin-bottom: 15px; }
        .results p { font-size: 1.1rem; color: #6b7280; margin-bottom: 30px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px; margin: 40px 0; }
        .stat { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); }
        .stat-value { font-size: 1.8rem; font-weight: 700; }
        #correctStat .stat-value { color: #10b981; }
        #incorrectStat .stat-value { color: #ef4444; }
        .stat-label { font-size: 0.9rem; color: #6b7280; margin-top: 5px; }

        .hidden { display: none !important; }

        @media (max-width: 768px) {
            body { padding: 0; }
            .container { border-radius: 0; min-height: 100vh; }
            .header { padding: 30px 20px; }
            .header h1 { font-size: 2rem; }
            .back-link { top: 15px; left: 15px; }
            .quiz-content, .controls, .progress-section { padding: 20px; }
            .controls { flex-direction: column; gap: 15px; }
            .current-stats { width: 100%; justify-content: space-around; }
        }
    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>üèóÔ∏è Design Patterns Quiz</h1>
        <a href="index.html" class="back-link">‚Üê Torna alla homepage</a>
    </header>

    <section class="progress-section" aria-live="polite">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text">
            Domanda <span id="currentQuestion">1</span> di <span id="totalQuestions">0</span>
        </div>
    </section>

    <main class="quiz-content" id="quizContent">
    </main>

    <footer class="controls">
        <button class="btn btn-secondary" id="prevBtn">‚Üê Precedente</button>
        <div class="current-stats">
            <span class="correct-count">Corrette: <span id="currentCorrectCount">0</span></span>
            <span class="incorrect-count">Sbagliate: <span id="currentIncorrectCount">0</span></span>
        </div>
        <div>
            <button class="btn btn-primary" id="showAnswerBtn">Mostra Risposta</button>
            <button class="btn btn-primary hidden" id="nextBtn">Successiva ‚Üí</button>
        </div>
    </footer>

    <section class="results hidden" id="results" aria-live="assertive">
        <div class="score-circle" id="scoreCircle">
            <div class="score-inner">
                <div class="score-percentage" id="scorePercentage">0%</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
        </div>
        <h2>Quiz Completato!</h2>
        <p>Ecco il riepilogo della tua sessione.</p>
        <div class="stats">
            <div class="stat" id="correctStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Corrette (su Totali)</div>
            </div>
            <div class="stat" id="incorrectStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Sbagliate (su Totali)</div>
            </div>
            <div class="stat" id="answeredCorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Corrette / Date</div>
            </div>
            <div class="stat" id="answeredIncorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Sbagliate / Date</div>
            </div>
        </div>
        <button class="btn btn-primary" id="restartBtn">üîÑ Ricomincia Quiz</button>
    </section>
</div>

<script>
    const allowedPatterns = [
        'Creator', 'Information Expert', 'Low Coupling', 'High Cohesion', 'Controller',
        'Abstract Factory', 'Singleton', 'Builder',
        'Adapter', 'Composite', 'Decorator', 'Facade',
        'Observer', 'State', 'Strategy', 'Visitor', 'Command', 'Iterator'
    ];
    const allowedTypes = ['Problema-Soluzione', 'UML'];

    const originalQuestions = [
        // GRASP
        { pattern: 'Creator', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Creator?', options: ['Chi deve essere responsabile per la creazione di istanze di una classe?', 'Come mantenere basso l\'accoppiamento tra classi?', 'Come assegnare responsabilit√† agli oggetti?', 'Come gestire la comunicazione tra oggetti?'], correct: 0, explanation: 'Il pattern Creator affronta il problema di determinare quale classe dovrebbe essere responsabile della creazione di istanze di altre classi.' },
        { pattern: 'Information Expert', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale soluzione propone il pattern Information Expert?', options: ['Centralizzare tutte le informazioni in una classe', 'Assegnare la responsabilit√† alla classe che ha le informazioni necessarie', 'Creare una classe dedicata per ogni tipo di informazione', 'Utilizzare variabili globali per condividere informazioni'], correct: 1, explanation: 'Information Expert suggerisce di assegnare la responsabilit√† alla classe che possiede le informazioni necessarie per svolgere quel compito.' },
        { pattern: 'Low Coupling', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale problema affronta il pattern Low Coupling?', options: ['Come aumentare la dipendenza tra classi?', 'Come ridurre l\'impatto dei cambiamenti e aumentare il riuso?', 'Come centralizzare le responsabilit√†?', 'Come aumentare le prestazioni del sistema?'], correct: 1, explanation: 'Low Coupling mira a ridurre le dipendenze tra classi per minimizzare l\'impatto dei cambiamenti e favorire il riuso.' },
        { pattern: 'High Cohesion', category: 'GRASP', type: 'Problema-Soluzione', question: 'Cosa promuove il pattern High Cohesion?', options: ['Classi con responsabilit√† molto diverse tra loro', 'Classi con responsabilit√† strettamente correlate e focalizzate', 'Classi con molte dipendenze esterne', 'Classi con metodi molto lunghi e complessi'], correct: 1, explanation: 'High Cohesion promuove classi con responsabilit√† strettamente correlate e ben focalizzate, rendendo il codice pi√π comprensibile e mantenibile.' },
        { pattern: 'Controller', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Controller?', options: ['Come gestire l\'interfaccia utente?', 'Chi dovrebbe gestire gli eventi di input del sistema?', 'Come implementare la persistenza dei dati?', 'Come ottimizzare le prestazioni del database?'], correct: 1, explanation: 'Il pattern Controller determina quale oggetto dovrebbe ricevere e coordinare (controllare) gli eventi di input del sistema.' },
        // GoF Creational
        { pattern: 'Singleton', category: 'GoF Creational', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Singleton?', options: ['Come creare famiglie di oggetti correlati?', 'Come garantire che una classe abbia una sola istanza?', 'Come separare la costruzione di oggetti complessi?', 'Come clonare oggetti prototipo?'], correct: 1, explanation: 'Singleton garantisce che una classe abbia una sola istanza e fornisce un punto di accesso globale ad essa.' },
        { pattern: 'Abstract Factory', category: 'GoF Creational', type: 'Problema-Soluzione', question: 'Quale soluzione fornisce il pattern Abstract Factory?', options: ['Crea una singola istanza globale', 'Fornisce un\'interfaccia per creare famiglie di oggetti correlati', 'Separa l\'algoritmo dalla struttura dati', 'Permette di aggiungere nuove operazioni senza modificare le classi'], correct: 1, explanation: 'Abstract Factory fornisce un\'interfaccia per creare famiglie di oggetti correlati o dipendenti senza specificare le loro classi concrete.' },
        // GoF Structural
        { pattern: 'Adapter', category: 'GoF Structural', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Adapter?', options: ['Come comporre oggetti in strutture ad albero?', 'Come permettere a classi con interfacce incompatibili di lavorare insieme?', 'Come aggiungere responsabilit√† a oggetti dinamicamente?', 'Come condividere efficientemente oggetti simili?'], correct: 1, explanation: 'Adapter permette a classi con interfacce incompatibili di lavorare insieme, agendo come un ponte tra di esse.' },
        { pattern: 'Composite', category: 'GoF Structural', type: 'Problema-Soluzione', question: 'Quale struttura crea il pattern Composite?', options: ['Una catena di oggetti collegati', 'Una struttura ad albero di oggetti', 'Una pila di oggetti', 'Una mappa di oggetti chiave-valore'], correct: 1, explanation: 'Composite permette di comporre oggetti in strutture ad albero per rappresentare gerarchie parte-tutto.' },
        { pattern: 'Decorator', category: 'GoF Structural', type: 'Problema-Soluzione', question: 'Come funziona il pattern Decorator?', options: ['Modifica direttamente la classe originale', 'Avvolge l\'oggetto originale in uno o pi√π wrapper', 'Sostituisce completamente l\'oggetto originale', 'Crea una copia modificata dell\'oggetto'], correct: 1, explanation: 'Decorator permette di aggiungere nuove funzionalit√† agli oggetti avvolgendoli in wrapper che contengono i nuovi comportamenti.' },
        // GoF Behavioral
        { pattern: 'Observer', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Observer?', options: ['Come iterare attraverso una collezione?', 'Come notificare automaticamente pi√π oggetti quando cambia lo stato?', 'Come incapsulare algoritmi intercambiabili?', 'Come gestire richieste in una catena di handler?'], correct: 1, explanation: 'Observer definisce una dipendenza uno-a-molti tra oggetti, cos√¨ quando uno cambia stato, tutti i dipendenti vengono notificati automaticamente.' },
        { pattern: 'State', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale soluzione propone il pattern State?', options: ['Usa un grande switch/if per gestire gli stati', 'Incapsula ogni stato in una classe separata', 'Memorizza tutti gli stati in un array', 'Ignora completamente il concetto di stato'], correct: 1, explanation: 'State permette a un oggetto di cambiare il suo comportamento quando il suo stato interno cambia, incapsulando ogni stato in una classe separata.' },
        { pattern: 'Strategy', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale problema affronta il pattern Strategy?', options: ['Come gestire le notifiche tra oggetti?', 'Come rendere algoritmi intercambiabili in runtime?', 'Come visitare elementi di una struttura complessa?', 'Come gestire stati complessi di un oggetto?'], correct: 1, explanation: 'Strategy definisce una famiglia di algoritmi, li incapsula e li rende intercambiabili durante l\'esecuzione.' },
        { pattern: 'Visitor', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale vantaggio offre il pattern Visitor?', options: ['Semplifica la struttura degli oggetti visitati', 'Permette di aggiungere nuove operazioni senza modificare le classi esistenti', 'Riduce il numero di classi nel sistema', 'Migliora le prestazioni dell\'accesso ai dati'], correct: 1, explanation: 'Visitor permette di definire nuove operazioni senza cambiare le classi degli elementi su cui opera, separando algoritmi dalla struttura.' },
        // UML
        { pattern: 'Creator', category: 'GRASP', type: 'UML', question: 'Nel diagramma UML del pattern Creator, quale relazione √® tipicamente mostrata?', options: ['Ereditariet√† tra creator e prodotto', 'Composizione o aggregazione tra creator e prodotto', 'Associazione bidirezionale', 'Dipendenza circolare'], correct: 1, explanation: 'Il Creator tipicamente ha una relazione di composizione o aggregazione con gli oggetti che crea, mostrata con diamante pieno o vuoto.' },
        { pattern: 'Singleton', category: 'GoF Creational', type: 'UML', question: 'Come √® rappresentato il costruttore nel diagramma UML di Singleton?', options: ['Pubblico (+)', 'Privato (-)', 'Protetto (#)', 'Statico (sottolineato)'], correct: 1, explanation: 'Nel Singleton, il costruttore √® privato (-) per impedire l\'istanziazione diretta dall\'esterno della classe.' },
        { pattern: 'Observer', category: 'GoF Behavioral', type: 'UML', question: 'Nel pattern Observer, quale interfaccia implementano tipicamente gli observer?', options: ['Subject', 'Observer o Listener', 'ConcreteSubject', 'Publisher'], correct: 1, explanation: 'Gli observer implementano un\'interfaccia Observer (o Listener) che definisce il metodo update() per ricevere notifiche.' },
        { pattern: 'Strategy', category: 'GoF Behavioral', type: 'UML', question: 'Nel diagramma UML di Strategy, il Context ha quale tipo di relazione con Strategy?', options: ['Ereditariet√†', 'Composizione', 'Realizzazione', 'Dipendenza semplice'], correct: 1, explanation: 'Il Context ha una relazione di composizione con l\'interfaccia Strategy, contenendo un riferimento ad essa.' },
        { pattern: 'Composite', category: 'GoF Structural', type: 'UML', question: 'Nel pattern Composite, come √® mostrata la relazione tra Composite e Component?', options: ['Aggregazione semplice', 'Composizione ricorsiva (Composite contiene Component)', 'Ereditariet√† multipla', 'Associazione bidirezionale'], correct: 1, explanation: 'Composite eredita da Component e contiene anche una collezione di Component, creando una struttura ricorsiva.' },
        { pattern: 'Decorator', category: 'GoF Structural', type: 'UML', question: 'Nel pattern Decorator, quale caratteristica ha la classe Decorator?', options: ['√à finale e non pu√≤ essere estesa', 'Implementa la stessa interfaccia del componente decorato', '√à statica e contiene solo metodi di utilit√†', '√à astratta e non pu√≤ essere istanziata'], correct: 1, explanation: 'Decorator implementa la stessa interfaccia del componente che decora, permettendo di sostituirlo trasparentemente.' },
    ];

    let questions = [];

    const dom = {
        quizContent: document.getElementById('quizContent'),
        progressFill: document.getElementById('progressFill'),
        currentQuestion: document.getElementById('currentQuestion'),
        totalQuestions: document.getElementById('totalQuestions'),
        prevBtn: document.getElementById('prevBtn'),
        nextBtn: document.getElementById('nextBtn'),
        showAnswerBtn: document.getElementById('showAnswerBtn'),
        restartBtn: document.getElementById('restartBtn'),
        results: document.getElementById('results'),
        scorePercentage: document.getElementById('scorePercentage'),
        correctStat: document.querySelector('#correctStat .stat-value'),
        incorrectStat: document.querySelector('#incorrectStat .stat-value'),
        answeredCorrectStat: document.querySelector('#answeredCorrectStat .stat-value'),
        answeredIncorrectStat: document.querySelector('#answeredIncorrectStat .stat-value'),
        scoreCircle: document.getElementById('scoreCircle'),
        progressSection: document.querySelector('.progress-section'),
        controls: document.querySelector('.controls'),
        currentCorrectCount: document.getElementById('currentCorrectCount'),
        currentIncorrectCount: document.getElementById('currentIncorrectCount'),
    };

    let state = {
        currentQuestionIndex: 0,
        userAnswers: [],
        isShowingAnswer: false,
    };

    function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    function shuffleOptionsAndCorrectIndex(question) {
        const optionsWithOriginalIndex = question.options.map((text, index) => ({ text, originalIndex: index }));
        const shuffledOptionsWithOriginalIndex = shuffleArray(optionsWithOriginalIndex);
        const newOptions = shuffledOptionsWithOriginalIndex.map(opt => opt.text);
        const newCorrectIndex = shuffledOptionsWithOriginalIndex.findIndex(opt => opt.originalIndex === question.correct);
        return { ...question, options: newOptions, correct: newCorrectIndex };
    }

    function getCategoryClass(category) {
        const classMap = {
            'GRASP': 'grasp',
            'GoF Creational': 'gof-creational',
            'GoF Structural': 'gof-structural',
            'GoF Behavioral': 'gof-behavioral',
        };
        return classMap[category] || '';
    }

    function initQuiz() {
        const filtered = originalQuestions.filter(q => allowedPatterns.includes(q.pattern) && allowedTypes.includes(q.type));
        questions = shuffleArray(filtered).map(q => shuffleOptionsAndCorrectIndex(q));

        state.currentQuestionIndex = 0;
        state.userAnswers = new Array(questions.length).fill(null).map(() => ({ userAnswer: null, correct: null }));
        state.isShowingAnswer = false;

        dom.results.classList.add('hidden');
        dom.quizContent.classList.remove('hidden');
        dom.controls.classList.remove('hidden');
        dom.progressSection.classList.remove('hidden');

        loadQuestion();
        updateProgress();
        updateNavigation();
        updateCurrentStats();
    }

    function loadQuestion() {
        state.isShowingAnswer = false;
        const question = questions[state.currentQuestionIndex];
        const userAnswer = state.userAnswers[state.currentQuestionIndex];

        dom.quizContent.innerHTML = `
            <div class="question-card" data-question-id="${question.pattern}">
                <div class="question-header">
                    <span class="pattern-category ${getCategoryClass(question.category)}">${question.category} - ${question.pattern}</span>
                    <span class="question-type">${question.type}</span>
                </div>
                <div class="question-text">${question.question}</div>
                <div class="options">
                    ${question.options.map((option, index) => `<div class="option" data-answer="${index}">${option}</div>`).join('')}
                </div>
                <div class="explanation hidden">
                    <h4>Spiegazione:</h4>
                    <p>${question.explanation}</p>
                </div>
            </div>
        `;

        if (userAnswer.userAnswer !== null) {
            const selectedOption = dom.quizContent.querySelector(`.option[data-answer="${userAnswer.userAnswer}"]`);
            if (selectedOption) selectedOption.classList.add('selected');

            if (userAnswer.correct !== null) {
                state.isShowingAnswer = true;
                const options = dom.quizContent.querySelectorAll('.option');
                options.forEach(opt => opt.classList.add('disabled'));
                const correctOption = dom.quizContent.querySelector(`.option[data-answer="${question.correct}"]`);
                if(correctOption) correctOption.classList.add('correct');
                if (!userAnswer.correct && selectedOption) {
                    selectedOption.classList.add('incorrect');
                }
                dom.quizContent.querySelector('.explanation').classList.remove('hidden');
            }
        }

        dom.showAnswerBtn.classList.toggle('hidden', state.isShowingAnswer);
        dom.nextBtn.classList.toggle('hidden', !state.isShowingAnswer);

        updateCurrentStats();
    }

    function handleOptionClick(event) {
        if (state.isShowingAnswer || !event.target.classList.contains('option')) return;

        const optionsContainer = event.currentTarget;
        optionsContainer.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
        const selectedOption = event.target;
        selectedOption.classList.add('selected');

        const answerIndex = parseInt(selectedOption.dataset.answer, 10);
        state.userAnswers[state.currentQuestionIndex].userAnswer = answerIndex;
    }

    function showAnswer() {
        if (state.userAnswers[state.currentQuestionIndex].userAnswer === null) {
            alert("Per favore, seleziona una risposta prima.");
            return;
        }

        const question = questions[state.currentQuestionIndex];
        const userAnswerIndex = state.userAnswers[state.currentQuestionIndex].userAnswer;
        const isCorrect = userAnswerIndex === question.correct;
        state.userAnswers[state.currentQuestionIndex].correct = isCorrect;

        state.isShowingAnswer = true;
        loadQuestion(); // Ricarica la domanda per mostrare lo stato aggiornato (corretto/sbagliato)
    }

    function navigate(direction) {
        const newIndex = state.currentQuestionIndex + direction;
        if (newIndex >= 0 && newIndex < questions.length) {
            state.currentQuestionIndex = newIndex;
            loadQuestion();
            updateProgress();
            updateNavigation();
        } else if (newIndex === questions.length) {
            showResults();
        }
    }

    function updateProgress() {
        const progress = ((state.currentQuestionIndex + 1) / questions.length) * 100;
        dom.progressFill.style.width = `${progress}%`;
        dom.currentQuestion.textContent = state.currentQuestionIndex + 1;
        dom.totalQuestions.textContent = questions.length;
    }

    function updateNavigation() {
        dom.prevBtn.disabled = state.currentQuestionIndex === 0;
        dom.nextBtn.textContent = state.currentQuestionIndex === questions.length - 1 ? 'üèÅ Termina Quiz' : 'Successiva ‚Üí';
    }

    function updateCurrentStats() {
        const correctCount = state.userAnswers.filter(a => a.correct === true).length;
        const incorrectCount = state.userAnswers.filter(a => a.correct === false).length;
        dom.currentCorrectCount.textContent = correctCount;
        dom.currentIncorrectCount.textContent = incorrectCount;
    }

    function showResults() {
        dom.quizContent.classList.add('hidden');
        dom.controls.classList.add('hidden');
        dom.progressSection.classList.add('hidden');
        dom.results.classList.remove('hidden');

        const totalQuestions = questions.length;
        const answeredQuestions = state.userAnswers.filter(a => a.userAnswer !== null);
        const answeredCount = answeredQuestions.length;
        const correctTotal = state.userAnswers.filter(a => a.correct === true).length;
        const incorrectTotal = state.userAnswers.filter(a => a.correct === false).length;

        const percentageTotal = totalQuestions > 0 ? Math.round((correctTotal / totalQuestions) * 100) : 0;

        dom.scorePercentage.textContent = `${percentageTotal}%`;
        dom.correctStat.textContent = correctTotal;
        dom.incorrectStat.textContent = incorrectTotal;
        dom.answeredCorrectStat.textContent = `${correctTotal} / ${answeredCount}`;
        dom.answeredIncorrectStat.textContent = `${incorrectTotal} / ${answeredCount}`;

        const gradientDegrees = (percentageTotal / 100) * 360;
        dom.scoreCircle.style.background = `conic-gradient(#4f46e5 ${gradientDegrees}deg, #e2e8f0 ${gradientDegrees}deg)`;
    }

    dom.quizContent.addEventListener('click', handleOptionClick);
    dom.showAnswerBtn.addEventListener('click', showAnswer);
    dom.nextBtn.addEventListener('click', () => navigate(1));
    dom.prevBtn.addEventListener('click', () => navigate(-1));
    dom.restartBtn.addEventListener('click', initQuiz);

    document.addEventListener('DOMContentLoaded', initQuiz);
</script>
</body>
</html>