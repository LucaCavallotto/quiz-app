<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Design Patterns</title>
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#ffffff">
    <style>
        /* Reset e Stili di Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Stili del corpo con gradiente e font moderno */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
        }

        /* Contenitore principale */
        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header del quiz */
        .header {
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative; /* Per posizionare la freccia di ritorno */
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .back-link {
            color: #cbd5e1;
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: #4f46e5; /* Cambia colore all'hover */
        }

        /* Sezione della barra di progresso */
        .progress-section {
            padding: 30px 40px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            transition: opacity 0.3s ease-in-out;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5, #06b6d4);
            width: 0%;
            transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            border-radius: 4px;
        }

        .score-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #475569;
        }

        /* Contenuto del quiz (domande) */
        .quiz-content {
            padding: 40px;
            flex-grow: 1;
            transition: opacity 0.3s ease-in-out;
        }

        /* Card della singola domanda */
        .question-card {
            background: white;
            border-radius: 16px;
            padding: 35px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border: 1px solid #f1f5f9;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .pattern-category, .question-type {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
        }

        /* Colori per le categorie */
        .grasp {
            background: linear-gradient(135deg, #10b981, #059669); /* Verde */
        }
        .gof-creational {
            background: linear-gradient(135deg, #f59e0b, #d97706); /* Arancione */
        }
        .gof-structural {
            background: linear-gradient(135deg, #3b82f6, #2563eb); /* Blu */
        }
        .gof-behavioral {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed); /* Viola */
        }

        .question-text {
            font-size: 1.15rem;
            line-height: 1.6;
            color: #1e293b;
            margin-bottom: 25px;
            font-weight: 500;
        }

        /* Opzioni di risposta */
        .options {
            display: grid;
            gap: 15px;
            margin-bottom: 25px;
        }

        .option {
            padding: 15px 25px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-align: left;
            color: #374151;
        }

        .option:not(.selected):not(.correct):not(.incorrect):hover {
            border-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.1);
        }

        .option.selected {
            border-color: #4f46e5;
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.2);
        }

        .option.correct {
            border-color: #10b981;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            transform: scale(1.02);
        }

        .option.incorrect {
            border-color: #ef4444;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .option.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Spiegazione della risposta */
        .explanation {
            margin-top: 25px;
            padding: 20px;
            background: #f1f5f9;
            border-radius: 10px;
            border-left: 4px solid #4f46e5;
            opacity: 0;
            animation: fadeIn 0.5s 0.2s forwards;
            display: none; /* Nascosto di default */
        }
        .explanation.show {
            display: block;
        }
        .explanation h4 {
            color: #4f46e5;
            margin-bottom: 10px;
        }
        .explanation p {
            color: #475569;
            line-height: 1.6;
        }
        .explanation strong {
            color: #4f46e5;
            font-weight: 700;
        }

        /* Controlli di navigazione */
        .controls {
            padding: 30px 40px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: opacity 0.3s ease-in-out;
            flex-wrap: wrap;
            gap: 15px;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:active {
            transform: translateY(1px) scale(0.98);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.2);
        }

        .btn-primary:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #475569;
        }

        .btn-secondary:not(:disabled):hover {
            background: #cbd5e1;
        }

        /* Sezione dei risultati */
        .results {
            text-align: center;
            padding: 60px 40px;
            opacity: 0;
            animation: fadeIn 0.6s forwards;
            display: none; /* Hidden by default */
        }

        .score-circle {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 30px;
            transition: background 1s ease-in-out;
        }

        .score-inner {
            width: 120px;
            height: 120px;
            background: white;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
        }

        .score-percentage {
            font-size: 2.2rem;
            font-weight: 700;
            color: #4f46e5;
        }

        .score-label {
            font-size: 0.9rem;
            color: #6b7280;
            margin-top: 5px;
        }

        .results h2 {
            font-size: 2rem;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .results p {
            font-size: 1.1rem;
            color: #6b7280;
            margin-bottom: 30px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }

        .stat {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
        }

        #correctStat .stat-value { color: #10b981; }
        #incorrectStat .stat-value { color: #ef4444; }
        #percentageStat .stat-value { color: #4f46e5; }

        .stat-label {
            font-size: 0.9rem;
            color: #6b7280;
            margin-top: 5px;
        }

        /* Classe di utilità */
        .hidden {
            display: none !important;
        }

        /* Modal Styles (for messages only, not AI explanation) */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            width: 90%;
            max-width: 500px; /* Smaller for messages */
            position: relative;
            animation: slideIn 0.3s forwards;
            display: flex;
            flex-direction: column;
            gap: 20px;
            text-align: center;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: #333;
        }

        .modal-content h2 {
            color: #4f46e5;
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .modal-message-output {
            line-height: 1.6;
            color: #374151;
        }

        /* Media Queries para responsività */
        @media (max-width: 768px) {
            body { padding: 0; }
            .container { border-radius: 0; min-height: 100vh; }
            .header { padding: 30px 20px; }
            .header h1 { font-size: 2rem; }
            .quiz-content, .controls { padding: 20px; }
            .question-header { flex-direction: column; align-items: flex-start; }
            .controls { flex-direction: column; gap: 15px; }
            .controls .btn { width: 100%; justify-content: center; }
            .progress-section { padding: 20px; }
            .score-panel {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
            .results { padding: 40px 20px; }
            .modal-content {
                padding: 20px;
                width: 95%;
            }
            .close-button {
                top: 10px;
                right: 15px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>🏗️ Design Patterns Quiz</h1>
        <a href="index.html" class="back-link">← Torna alla homepage</a>
    </div>

    <div class="progress-section">
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div class="score-panel">
            <div>
                <strong>Punteggio: <span id="score">0</span>/<span id="total-answered">0</span></strong>
            </div>
            <div>
                <strong>Domanda <span id="current-question">1</span> di <span id="total-questions">0</span></strong>
            </div>
        </div>
    </div>

    <div class="quiz-content" id="quiz-content">
        <div class="question-card">
            <div class="question-header">
                <span id="pattern-category" class="pattern-category"></span>
                <span id="question-type" class="question-type"></span>
            </div>
            <div id="question-text" class="question-text"></div>
            <div id="options" class="options"></div>
            <div id="feedback" class="explanation">
                <h4>Spiegazione:</h4>
                <p id="explanation-text"></p>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="prev-btn" class="btn btn-secondary" disabled>← Precedente</button>
        <button id="check-btn" class="btn btn-primary" disabled>Verifica Risposta</button>
        <button id="next-btn" class="btn btn-primary" disabled>Successiva →</button>
    </div>

    <section class="results hidden" id="results" aria-live="assertive">
        <div class="score-circle" id="scoreCircle">
            <div class="score-inner">
                <div class="score-percentage" id="scorePercentage">0%</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
        </div>
        <h2>Quiz Completato!</h2>
        <p>Ecco il riepilogo della tua sessione.</p>

        <div class="stats">
            <div class="stat" id="correctStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Corrette (su Totali)</div>
            </div>
            <div class="stat" id="incorrectStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Sbagliate (su Totali)</div>
            </div>
            <div class="stat" id="answeredCorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Corrette / Date</div>
            </div>
            <div class="stat" id="answeredIncorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Sbagliate / Date</div>
            </div>
        </div>

        <button class="btn btn-primary" id="restart-btn">
            🔄 Ricomincia Quiz
        </button>
    </section>
</div>

<div id="messageModal" class="modal hidden">
    <div class="modal-content">
        <span class="close-button" id="closeMessageModalBtn">&times;</span>
        <h2 id="message-modal-title"></h2>
        <div id="message-modal-output" class="modal-message-output"></div>
    </div>
</div>

<script>
    const allowedPatterns = [
        'Creator', 'Information Expert', 'Low Coupling', 'High Cohesion', 'Controller', // GRASP
        'Abstract Factory', 'Singleton', // GoF Creational
        'Adapter', 'Composite', 'Decorator', // GoF Structural
        'Observer', 'State', 'Strategy', 'Visitor' // GoF Behavioral
    ];

    const allowedTypes = ['Problema-Soluzione', 'UML'];

    const originalQuestions = [
        {
            pattern: 'Creator',
            category: 'GRASP',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Creator?',
            options: [
                'Chi deve essere responsabile per la creazione di istanze di una classe?',
                'Come mantenere basso l\'accoppiamento tra classi?',
                'Come assegnare responsabilità agli oggetti?',
                'Come gestire la comunicazione tra oggetti?'
            ],
            correct: 0, // This index will be updated after shuffling options
            explanation: 'Il pattern Creator affronta il problema di determinare quale classe dovrebbe essere responsabile della creazione di istanze di altre classi.'
        },
        {
            pattern: 'Information Expert',
            category: 'GRASP',
            type: 'Problema-Soluzione',
            question: 'Quale soluzione propone il pattern Information Expert?',
            options: [
                'Centralizzare tutte le informazioni in una classe',
                'Assegnare la responsabilità alla classe che ha le informazioni necessarie',
                'Creare una classe dedicata per ogni tipo di informazione',
                'Utilizzare variabili globali per condividere informazioni'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Information Expert suggerisce di assegnare la responsabilità alla classe che possiede le informazioni necessarie per svolgere quel compito.'
        },
        {
            pattern: 'Low Coupling',
            category: 'GRASP',
            type: 'Problema-Soluzione',
            question: 'Quale problema affronta il pattern Low Coupling?',
            options: [
                'Come aumentare la dipendenza tra classi?',
                'Come ridurre l\'impatto dei cambiamenti e aumentare il riuso?',
                'Come centralizzare le responsabilità?',
                'Come aumentare le prestazioni del sistema?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Low Coupling mira a ridurre le dipendenze tra classi per minimizzare l\'impatto dei cambiamenti e favorire il riuso.'
        },
        {
            pattern: 'High Cohesion',
            category: 'GRASP',
            type: 'Problema-Soluzione',
            question: 'Cosa promuove il pattern High Cohesion?',
            options: [
                'Classi con responsabilità molto diverse tra loro',
                'Classi con responsabilità strettamente correlate e focalizzate',
                'Classi con molte dipendenze esterne',
                'Classi con metodi molto lunghi e complessi'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'High Cohesion promuove classi con responsabilità strettamente correlate e ben focalizzate, rendendo il codice più comprensibile e mantenibile.'
        },
        {
            pattern: 'Controller',
            category: 'GRASP',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Controller?',
            options: [
                'Come gestire l\'interfaccia utente?',
                'Chi dovrebbe gestire gli eventi di input del sistema?',
                'Come implementare la persistenza dei dati?',
                'Come ottimizzare le prestazioni del database?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Il pattern Controller determina quale oggetto dovrebbe ricevere e coordinare (controllare) gli eventi di input del sistema.'
        },
        {
            pattern: 'Singleton',
            category: 'GoF Creational',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Singleton?',
            options: [
                'Come creare famiglie di oggetti correlati?',
                'Come garantire che una classe abbia una sola istanza?',
                'Come separare la costruzione di oggetti complessi?',
                'Come clonare oggetti prototipo?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Singleton garantisce che una classe abbia una sola istanza e fornisce un punto di accesso globale ad essa.'
        },
        {
            pattern: 'Abstract Factory',
            category: 'GoF Creational',
            type: 'Problema-Soluzione',
            question: 'Quale soluzione fornisce il pattern Abstract Factory?',
            options: [
                'Crea una singola istanza globale',
                'Fornisce un\'interfaccia per creare famiglie di oggetti correlati',
                'Separa l\'algoritmo dalla struttura dati',
                'Permette di aggiungere nuove operazioni senza modificare le classi'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Abstract Factory fornisce un\'interfaccia per creare famiglie di oggetti correlati o dipendenti senza specificare le loro classi concrete.'
        },
        {
            pattern: 'Adapter',
            category: 'GoF Structural',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Adapter?',
            options: [
                'Come comporre oggetti in strutture ad albero?',
                'Come permettere a classi con interfacce incompatibili di lavorare insieme?',
                'Come aggiungere responsabilità a oggetti dinamicamente?',
                'Come condividere efficientemente oggetti simili?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Adapter permette a classi con interfacce incompatibili di lavorare insieme, agendo come un ponte tra di esse.'
        },
        {
            pattern: 'Composite',
            category: 'GoF Structural',
            type: 'Problema-Soluzione',
            question: 'Quale struttura crea il pattern Composite?',
            options: [
                'Una catena di oggetti collegati',
                'Una struttura ad albero di oggetti',
                'Una pila di oggetti',
                'Una mappa di oggetti chiave-valore'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Composite permette di comporre oggetti in strutture ad albero per rappresentare gerarchie parte-tutto.'
        },
        {
            pattern: 'Decorator',
            category: 'GoF Structural',
            type: 'Problema-Soluzione',
            question: 'Come funziona il pattern Decorator?',
            options: [
                'Modifica direttamente la classe originale',
                'Avvolge l\'oggetto originale in uno o più wrapper',
                'Sostituisce completamente l\'oggetto originale',
                'Crea una copia modificata dell\'oggetto'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Decorator permette di aggiungere nuove funzionalità agli oggetti avvolgendoli in wrapper che contengono i nuovi comportamenti.'
        },
        {
            pattern: 'Observer',
            category: 'GoF Behavioral',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Observer?',
            options: [
                'Come iterare attraverso una collezione?',
                'Come notificare automaticamente più oggetti quando cambia lo stato?',
                'Come incapsulare algoritmi intercambiabili?',
                'Come gestire richieste in una catena di handler?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Observer definisce una dipendenza uno-a-molti tra oggetti, così quando uno cambia stato, tutti i dipendenti vengono notificati automaticamente.'
        },
        {
            pattern: 'State',
            category: 'GoF Behavioral',
            type: 'Problema-Soluzione',
            question: 'Quale soluzione propone il pattern State?',
            options: [
                'Usa un grande switch/if per gestire gli stati',
                'Incapsula ogni stato in una classe separata',
                'Memorizza tutti gli stati in un array',
                'Ignora completamente il concetto di stato'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'State permette a un oggetto di cambiare il suo comportamento quando il suo stato interno cambia, incapsulando ogni stato in una classe separata.'
        },
        {
            pattern: 'Strategy',
            category: 'GoF Behavioral',
            type: 'Problema-Soluzione',
            question: 'Quale problema affronta il pattern Strategy?',
            options: [
                'Come gestire le notifiche tra oggetti?',
                'Come rendere algoritmi intercambiabili in runtime?',
                'Come visitare elementi di una struttura complessa?',
                'Come gestire stati complessi di un oggetto?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Strategy definisce una famiglia di algoritmi, li incapsula e li rende intercambiabili durante l\'esecuzione.'
        },
        {
            pattern: 'Visitor',
            category: 'GoF Behavioral',
            type: 'Problema-Soluzione',
            question: 'Quale vantaggio offre il pattern Visitor?',
            options: [
                'Semplifica la struttura degli oggetti visitati',
                'Permette di aggiungere nuove operazioni senza modificare le classi esistenti',
                'Riduce il numero di classi nel sistema',
                'Migliora le prestazioni dell\'accesso ai dati'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Visitor permette di definire nuove operazioni senza cambiare le classi degli elementi su cui opera, separando algoritmi dalla struttura.'
        },
        {
            pattern: 'Creator',
            category: 'GRASP',
            type: 'UML',
            question: 'Nel diagramma UML del pattern Creator, quale relazione è tipicamente mostrata?',
            options: [
                'Ereditarietà tra creator e prodotto',
                'Composizione o aggregazione tra creator e prodotto',
                'Associazione bidirezionale',
                'Dipendenza circolare'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Il Creator tipicamente ha una relazione di composizione o aggregazione con gli oggetti che crea, mostrata con diamante pieno o vuoto.'
        },
        {
            pattern: 'Singleton',
            category: 'GoF Creational',
            type: 'UML',
            question: 'Come è rappresentato il costruttore nel diagramma UML di Singleton?',
            options: [
                'Pubblico (+)',
                'Privato (-)',
                'Protetto (#)',
                'Statico (sottolineato)'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Nel Singleton, il costruttore è privato (-) per impedire l\'istanziazione diretta dall\'esterno della classe.'
        },
        {
            pattern: 'Observer',
            category: 'GoF Behavioral',
            type: 'UML',
            question: 'Nel pattern Observer, quale interfaccia implementano tipicamente gli observer?',
            options: [
                'Subject',
                'Observer o Listener',
                'ConcreteSubject',
                'Publisher'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Gli observer implementano un\'interfaccia Observer (o Listener) che definisce il metodo update() per ricevere notifiche.'
        },
        {
            pattern: 'Strategy',
            category: 'GoF Behavioral',
            type: 'UML',
            question: 'Nel diagramma UML di Strategy, il Context ha quale tipo di relazione con Strategy?',
            options: [
                'Ereditarietà',
                'Composizione',
                'Realizzazione',
                'Dipendenza semplice'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Il Context ha una relazione di composizione con l\'interfaccia Strategy, contenendo un riferimento ad essa.'
        },
        {
            pattern: 'Composite',
            category: 'GoF Structural',
            type: 'UML',
            question: 'Nel pattern Composite, come è mostrata la relazione tra Composite e Component?',
            options: [
                'Aggregazione semplice',
                'Composizione ricorsiva (Composite contiene Component)',
                'Ereditarietà multipla',
                'Associazione bidirezionale'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Composite eredita da Component e contiene anche una collezione di Component, creando una struttura ricorsiva.'
        },
        {
            pattern: 'Decorator',
            category: 'GoF Structural',
            type: 'UML',
            question: 'Nel pattern Decorator, quale caratteristica ha la classe Decorator?',
            options: [
                'È finale e non può essere estesa',
                'Implementa la stessa interfaccia del componente decorato',
                'È statica e contiene solo metodi di utilità',
                'È astratta e non può essere istanziata'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Decorator implementa la stessa interfaccia del componente che decora, permettendo di sostituirlo trasparentemente.'
        },
        {
            pattern: 'Facade',
            category: 'GoF Structural',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Facade?',
            options: [
                'Come nascondere la complessità di un sottosistema fornendo un\'interfaccia unificata?',
                'Come creare oggetti senza specificare la classe esatta dell\'oggetto che sarà creato?',
                'Come aggiungere nuove operazioni senza modificare le classi esistenti?',
                'Come notificare automaticamente più oggetti quando cambia lo stato?'
            ],
            correct: 0, // This index will be updated after shuffling options
            explanation: 'Il pattern Facade fornisce un\'interfaccia unificata per un insieme di interfacce in un sottosistema, rendendolo più facile da usare.'
        },
        {
            pattern: 'Builder',
            category: 'GoF Creational',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Builder?',
            options: [
                'Come garantire che una classe abbia una sola istanza?',
                'Come separare la costruzione di un oggetto complesso dalla sua rappresentazione?',
                'Come creare famiglie di oggetti correlati?',
                'Come clonare oggetti prototipo?'
            ],
            correct: 1, // This index will be updated after shuffling options
            explanation: 'Il pattern Builder serve a separare la costruzione di un oggetto complesso dalla sua rappresentazione, in modo che lo stesso processo di costruzione possa creare diverse rappresentazioni.'
        },
        {
            pattern: 'Command',
            category: 'GoF Behavioral',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Command?',
            options: [
                'Come incapsulare una richiesta come un oggetto?',
                'Come definire una famiglia di algoritmi?',
                'Come notificare automaticamente più oggetti?',
                'Come gestire stati complessi di un oggetto?'
            ],
            correct: 0, // This index will be updated after shuffling options
            explanation: 'Il pattern Command incapsula una richiesta come un oggetto, consentendo così di parametrizzare i client con diverse richieste, accodare o registrare richieste e supportare operazioni annullabili.'
        },
        {
            pattern: 'Iterator',
            category: 'GoF Behavioral',
            type: 'Problema-Soluzione',
            question: 'Quale problema risolve il pattern Iterator?',
            options: [
                'Come accedere sequenzialmente agli elementi di una collezione senza esporre la sua rappresentazione sottostante?',
                'Come definire una famiglia di algoritmi?',
                'Come notificare automaticamente più oggetti?',
                'Come gestire stati complessi di un oggetto?'
            ],
            correct: 0, // This index will be updated after shuffling options
            explanation: 'Il pattern Iterator fornisce un modo per accedere sequenzialmente agli elementi di una collezione senza esporre la sua rappresentazione sottostante, promuovendo il disaccoppiamento.'
        }
    ];

    let questions = []; // This will hold the filtered and shuffled questions
    let currentQuestionIndex = 0;
    let score = 0;
    // Stores {questionIndex: {userAnswer: index, correct: boolean, shownAnswer: boolean}}
    let answeredQuestions = new Map();

    const dom = {
        questionText: document.getElementById('question-text'),
        optionsContainer: document.getElementById('options'),
        feedbackDiv: document.getElementById('feedback'),
        explanationText: document.getElementById('explanation-text'),
        checkBtn: document.getElementById('check-btn'),
        nextBtn: document.getElementById('next-btn'),
        prevBtn: document.getElementById('prev-btn'),
        currentQuestionSpan: document.getElementById('current-question'),
        totalQuestionsSpan: document.getElementById('total-questions'),
        scoreSpan: document.getElementById('score'),
        totalAnsweredSpan: document.getElementById('total-answered'),
        progressFill: document.getElementById('progress-fill'),
        patternCategorySpan: document.getElementById('pattern-category'),
        questionTypeSpan: document.getElementById('question-type'),
        quizContent: document.getElementById('quiz-content').closest('.quiz-content'),
        controls: document.querySelector('.controls'),
        progressSection: document.querySelector('.progress-section'),
        resultsSection: document.getElementById('results'),
        scorePercentage: document.getElementById('scorePercentage'),
        correctStat: document.getElementById('correctStat').querySelector('.stat-value'),
        incorrectStat: document.getElementById('incorrectStat').querySelector('.stat-value'),
        answeredCorrectStat: document.getElementById('answeredCorrectStat').querySelector('.stat-value'),
        answeredIncorrectStat: document.getElementById('answeredIncorrectStat').querySelector('.stat-value'),
        scoreCircle: document.getElementById('scoreCircle'),
        restartBtn: document.getElementById('restart-btn'),
        // Message Modal related DOM elements
        messageModal: document.getElementById('messageModal'),
        closeMessageModalBtn: document.getElementById('closeMessageModalBtn'),
        messageModalTitle: document.getElementById('message-modal-title'),
        messageModalOutput: document.getElementById('message-modal-output')
    };

    // Function to shuffle an array (Fisher-Yates algorithm)
    function shuffleArray(array) {
        const shuffled = [...array]; // Create a copy
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    // Function to get category CSS class
    function getCategoryClass(category) {
        if (category === 'GRASP') return 'grasp';
        if (category === 'GoF Creational') return 'gof-creational';
        if (category === 'GoF Structural') return 'gof-structural';
        if (category === 'GoF Behavioral') return 'gof-behavioral';
        return '';
    }

    // Helper function to show messages in the modal
    function showMessageModal(title, message) {
        dom.messageModalTitle.textContent = title;
        dom.messageModalOutput.innerHTML = message;
        dom.messageModal.classList.remove('hidden');
    }

    // Function to filter questions based on allowed patterns and types
    function filterQuestions(allQuestions) {
        return allQuestions.filter(q => {
            const isAllowedPattern = allowedPatterns.includes(q.pattern);
            const isAllowedType = allowedTypes.includes(q.type);
            return isAllowedPattern && isAllowedType;
        });
    }

    // Function to shuffle options for a question and update the correct index
    function shuffleOptionsAndCorrectIndex(question) {
        const optionsWithOriginalIndex = question.options.map((text, index) => ({ text, originalIndex: index }));
        const shuffledOptionsWithOriginalIndex = shuffleArray(optionsWithOriginalIndex);

        const newOptions = shuffledOptionsWithOriginalIndex.map(opt => opt.text);
        const newCorrectIndex = shuffledOptionsWithOriginalIndex.findIndex(opt => opt.originalIndex === question.correct);

        return {
            ...question,
            options: newOptions,
            correct: newCorrectIndex
        };
    }

    // Function to initialize or reset the quiz
    function initQuiz() {
        // Filter questions first
        const filtered = filterQuestions(originalQuestions);
        // Then shuffle options for each filtered question and update correct index
        questions = filtered.map(q => shuffleOptionsAndCorrectIndex(q));

        currentQuestionIndex = 0;
        score = 0;
        answeredQuestions.clear(); // Clear previous answers

        // Show quiz elements, hide results
        dom.quizContent.classList.remove('hidden');
        dom.controls.classList.remove('hidden');
        dom.progressSection.classList.remove('hidden');
        dom.resultsSection.classList.add('hidden');

        displayQuestion();
        updateProgress();
        updateNavigationButtons();
    }

    // Function to display the current question
    function displayQuestion() {
        const question = questions[currentQuestionIndex];

        dom.patternCategorySpan.textContent = `${question.category} - ${question.pattern}`;
        dom.patternCategorySpan.className = `pattern-category ${getCategoryClass(question.category)}`;
        dom.questionTypeSpan.textContent = question.type;
        dom.questionText.textContent = question.question;

        dom.optionsContainer.innerHTML = ''; // Clear previous options
        dom.feedbackDiv.classList.remove('show'); // Hide feedback

        question.options.forEach((optionText, index) => {
            const optionDiv = document.createElement('div');
            optionDiv.classList.add('option');
            optionDiv.textContent = optionText;
            optionDiv.dataset.index = index; // Store current index for checking
            optionDiv.addEventListener('click', handleOptionClick);
            dom.optionsContainer.appendChild(optionDiv);
        });

        // Reset button states
        dom.checkBtn.disabled = true;
        dom.nextBtn.disabled = true;

        // If the question has been answered before, restore its state
        if (answeredQuestions.has(currentQuestionIndex)) {
            const savedAnswer = answeredQuestions.get(currentQuestionIndex);
            const options = dom.optionsContainer.querySelectorAll('.option');

            options.forEach(option => {
                option.classList.add('disabled'); // Disable interaction
                const optionIndex = parseInt(option.dataset.index);

                if (optionIndex === question.correct) {
                    option.classList.add('correct'); // Mark correct answer
                }
                if (optionIndex === savedAnswer.userAnswer && optionIndex !== question.correct) {
                    option.classList.add('incorrect'); // Mark user's incorrect answer
                }
            });

            dom.explanationText.textContent = question.explanation;
            dom.feedbackDiv.classList.add('show'); // Show explanation
            dom.checkBtn.disabled = true;
            dom.nextBtn.disabled = false;
        }

        updateNavigationButtons();
        updateProgress();
    }

    // Function to handle option selection
    function handleOptionClick(event) {
        const options = dom.optionsContainer.querySelectorAll('.option');
        options.forEach(option => option.classList.remove('selected')); // Deselect all

        event.target.classList.add('selected'); // Select clicked option
        dom.checkBtn.disabled = false; // Enable check button
    }

    // Function to check the selected answer
    function checkAnswer() {
        const selectedOption = dom.optionsContainer.querySelector('.option.selected');
        if (!selectedOption) {
            showMessageModal('Attenzione!', 'Seleziona una risposta prima di verificare!');
            return;
        }

        const selectedAnswerIndex = parseInt(selectedOption.dataset.index);
        const question = questions[currentQuestionIndex];
        const isCorrect = (selectedAnswerIndex === question.correct);

        // Disable all options after checking
        dom.optionsContainer.querySelectorAll('.option').forEach(option => {
            option.classList.add('disabled');
            const optionIndex = parseInt(option.dataset.index);
            if (optionIndex === question.correct) {
                option.classList.add('correct');
            } else if (optionIndex === selectedAnswerIndex) {
                option.classList.add('incorrect');
            }
        });

        if (isCorrect && !answeredQuestions.has(currentQuestionIndex)) {
            score++; // Increment score only if it's the first correct attempt for this question
        }
        answeredQuestions.set(currentQuestionIndex, { userAnswer: selectedAnswerIndex, correct: isCorrect, shownAnswer: false });

        dom.explanationText.textContent = question.explanation;
        dom.feedbackDiv.classList.add('show');

        dom.checkBtn.disabled = true;
        dom.nextBtn.disabled = false; // Enable next button
        updateProgress();
    }

    // Function to navigate between questions
    function navigate(direction) {
        if (direction === 1) { // Next
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            } else {
                showResults(); // End of quiz
            }
        } else if (direction === -1) { // Previous
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        }
    }

    // Function to update progress bar and score display
    function updateProgress() {
        const totalQuestions = questions.length;
        dom.currentQuestionSpan.textContent = currentQuestionIndex + 1;
        dom.totalQuestionsSpan.textContent = totalQuestions;
        dom.scoreSpan.textContent = score;
        dom.totalAnsweredSpan.textContent = answeredQuestions.size;

        const progressPercentage = ((currentQuestionIndex + 1) / totalQuestions) * 100;
        dom.progressFill.style.width = `${progressPercentage}%`;
    }

    // Function to update navigation button states
    function updateNavigationButtons() {
        dom.prevBtn.disabled = currentQuestionIndex === 0;
        dom.nextBtn.textContent = currentQuestionIndex === questions.length - 1 ? '🏁 Termina Quiz' : 'Successiva →';
        // Next button is enabled only if the current question has been answered (or answer shown)
        dom.nextBtn.disabled = !answeredQuestions.has(currentQuestionIndex);
    }

    // Function to show final results
    function showResults() {
        dom.quizContent.classList.add('hidden');
        dom.controls.classList.add('hidden');
        dom.progressSection.classList.add('hidden');
        dom.resultsSection.classList.remove('hidden');

        const totalQuestions = questions.length;
        const correctTotal = score;
        const answeredCount = answeredQuestions.size;
        const incorrectTotal = answeredCount - correctTotal;

        const percentageTotal = totalQuestions > 0 ? Math.round((correctTotal / totalQuestions) * 100) : 0;

        // Stats for answered questions
        const correctOfAnswered = Array.from(answeredQuestions.values()).filter(ans => ans.correct === true).length;
        const incorrectOfAnswered = Array.from(answeredQuestions.values()).filter(ans => ans.correct === false).length;

        dom.scorePercentage.textContent = `${percentageTotal}%`;
        dom.correctStat.textContent = correctTotal;
        dom.incorrectStat.textContent = incorrectTotal;
        dom.answeredCorrectStat.textContent = `${correctOfAnswered} / ${answeredCount}`;
        dom.answeredIncorrectStat.textContent = `${incorrectOfAnswered} / ${answeredCount}`;

        const gradientDegrees = (percentageTotal / 100) * 360;
        dom.scoreCircle.style.background = `conic-gradient(#4f46e5 ${gradientDegrees}deg, #e2e8f0 ${gradientDegrees}deg)`;
    }

    // Close message modal functionality
    dom.closeMessageModalBtn.addEventListener('click', () => {
        dom.messageModal.classList.add('hidden');
    });

    // Close message modal if clicked outside content
    window.addEventListener('click', (event) => {
        if (event.target === dom.messageModal) {
            dom.messageModal.classList.add('hidden');
        }
    });


    // Event Listeners for quiz controls
    dom.checkBtn.addEventListener('click', checkAnswer);
    dom.nextBtn.addEventListener('click', () => navigate(1));
    dom.prevBtn.addEventListener('click', () => navigate(-1));
    dom.restartBtn.addEventListener('click', initQuiz);

    // Initialize quiz on page load
    document.addEventListener('DOMContentLoaded', initQuiz);
</script>
</body>
</html>
