<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Design Patterns</title>
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#ffffff">
    <style>
        /* Reset e Stili di Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Stili del corpo con gradiente e font moderno */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
        }

        /* Contenitore principale */
        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header del quiz */
        .header {
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative; /* Per posizionare la freccia di ritorno */
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #cbd5e1;
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: white;
        }

        /* Sezione della barra di progresso */
        .progress-section {
            padding: 30px 40px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            transition: opacity 0.3s ease-in-out;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5, #06b6d4);
            width: 0%;
            transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            border-radius: 4px;
        }

        .progress-text {
            font-weight: 600;
            color: #475569;
        }

        /* Contenuto del quiz (domande) */
        .quiz-content {
            padding: 40px;
            flex-grow: 1;
            transition: opacity 0.3s ease-in-out;
        }

        /* Card della singola domanda */
        .question-card {
            background: white;
            border-radius: 16px;
            padding: 35px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            border: 1px solid #f1f5f9;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .pattern-category, .question-type {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
        }

        /* Colori per le categorie */
        .grasp { background: linear-gradient(135deg, #10b981, #059669); }
        .gof-creational { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .gof-structural { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .gof-behavioral { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }

        .question-text {
            font-size: 1.15rem;
            line-height: 1.6;
            color: #1e293b;
            margin-bottom: 25px;
            font-weight: 500;
        }

        /* Opzioni di risposta */
        .options {
            display: grid;
            gap: 15px;
            margin-bottom: 25px;
        }

        .option {
            padding: 15px 25px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-align: left;
            color: #374151;
        }

        .option:not(.selected):not(.correct):not(.incorrect):hover {
            border-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.1);
        }

        .option.selected {
            border-color: #4f46e5;
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.2);
        }

        .option.correct {
            border-color: #10b981;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .option.incorrect {
            border-color: #ef4444;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .option.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Spiegazione della risposta */
        .explanation {
            margin-top: 25px;
            padding: 20px;
            background: #f1f5f9;
            border-radius: 10px;
            border-left: 4px solid #4f46e5;
            animation: fadeIn 0.5s 0.2s forwards;
        }
        .explanation h4 { color: #4f46e5; margin-bottom: 10px; }
        .explanation p { color: #475569; line-height: 1.6; }

        /* Controlli di navigazione */
        .controls {
            padding: 30px 40px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: linear-gradient(135deg, #4f46e5, #06b6d4); color: white; }
        .btn-secondary { background: #e2e8f0; color: #475569; }
        .btn-danger { background: linear-gradient(135deg, #ef4444, #b91c1c); color: white; }

        .current-stats {
            display: flex;
            gap: 20px;
            font-weight: 600;
            color: #475569;
            flex-grow: 1;
            justify-content: center;
        }
        .current-stats .correct-count { color: #10b981; }
        .current-stats .incorrect-count { color: #ef4444; }

        .progress-text-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px; /* Spazio tra testo progresso e dropdown */
            margin-top: 10px; /* Spazio dalla barra di progresso */
            margin-bottom: 15px; /* Spazio prima della mappa delle domande */
        }

        /* .progress-text è già definito */

        .question-jump-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .question-jump-section label {
            font-weight: 500;
            color: #475569;
            font-size: 0.9rem;
        }

        #questionJump {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #cbd5e1; /* Bordo più leggero */
            background-color: white;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        #questionJump:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }


        /* Stili per la Mappa delle Domande */
        .question-map {
            display: flex;
            flex-wrap: wrap;
            gap: 6px; /* Spazio tra i marcatori */
            padding-top: 10px; /* Spazio sopra la mappa */
            border-top: 1px solid #e2e8f0; /* Separatore leggero */
            margin-top: 15px;
        }

        .question-marker {
            width: 28px; /* Leggermente più piccoli */
            height: 28px;
            border: 1px solid #d1d5db; /* Grigio chiaro */
            border-radius: 50%; /* Cerchi */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: #4b5563; /* Grigio scuro per il testo */
            cursor: pointer;
            background-color: #f9fafb; /* Sfondo molto chiaro */
            transition: all 0.2s ease-in-out;
        }

        .question-marker:hover {
            border-color: #6366f1; /* Viola per hover */
            background-color: #eef2ff; /* Sfondo viola molto chiaro */
            color: #4338ca;
        }

        .question-marker.current {
            border-color: #4f46e5;
            background-color: #4f46e5;
            color: white;
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }

        .question-marker.answered {
            background-color: #e5e7eb; /* Grigio più scuro per risposte date (non ancora valutate) */
            border-color: #9ca3af;
            color: #374151;
        }

        .question-marker.correct {
            background-color: #10b981; /* Verde */
            color: white;
            border-color: #059669;
        }

        .question-marker.incorrect {
            background-color: #ef4444; /* Rosso */
            color: white;
            border-color: #dc2626;
        }

        /* Sezione dei risultati */
        .results { text-align: center; padding: 60px 40px; }
        .score-circle { width: 150px; height: 150px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 30px; }
        .score-inner { width: 120px; height: 120px; background: white; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .score-percentage { font-size: 2.2rem; font-weight: 700; color: #4f46e5; }
        .score-label { font-size: 0.9rem; color: #6b7280; margin-top: 5px; }
        .results h2 { font-size: 2rem; color: #1e293b; margin-bottom: 15px; }
        .results p { font-size: 1.1rem; color: #6b7280; margin-bottom: 30px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px; margin: 40px 0; }
        .stat { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); }
        .stat-value { font-size: 1.8rem; font-weight: 700; }
        #correctStat .stat-value { color: #10b981; }
        #incorrectStat .stat-value { color: #ef4444; }
        .stat-label { font-size: 0.9rem; color: #6b7280; margin-top: 5px; }

        .hidden { display: none !important; }

        @media (max-width: 768px) {
            body { padding: 0; }
            .container { border-radius: 0; min-height: 100vh; }
            .header { padding: 30px 20px; }
            .header h1 { font-size: 2rem; }
            .back-link { top: 15px; left: 15px; }
            .quiz-content, .controls, .progress-section { padding: 20px; }
            .controls { flex-direction: column; gap: 15px; }
            .current-stats { width: 100%; justify-content: space-around; }
            .progress-section { padding: 20px; }
            .progress-text-container {
                flex-direction: column; /* Impila gli elementi verticalmente */
                align-items: flex-start; /* Allinea a sinistra */
                gap: 12px;
            }
            .question-jump-section {
                width: 100%; /* Occupa tutta la larghezza */
            }
            #questionJump {
                flex-grow: 1; /* Fa espandere il select */
            }
            .question-map {
                justify-content: center; /* Centra i marcatori se non riempiono la riga */
            }
        }

    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>🏗️ Design Patterns Quiz</h1>
        <a href="index.html" class="back-link">← Torna alla homepage</a>
    </header>

    <section class="progress-section" aria-live="polite">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text-container">
            <span class="progress-text">
                Domanda <span id="currentQuestion">1</span> di <span id="totalQuestions">0</span>
            </span>
            <div class="question-jump-section">
                <label for="questionJump">Vai a:</label>
                <select id="questionJump"></select>
            </div>
        </div>
        <div id="questionMap" class="question-map">
            </div>
    </section>

    <main class="quiz-content" id="quizContent">
    </main>

    <footer class="controls">
        <button class="btn btn-secondary" id="prevBtn">← Precedente</button>
        <button class="btn btn-danger" id="stopBtn">Ferma Quiz</button>
        <div class="current-stats">
            <span class="correct-count">Corrette: <span id="currentCorrectCount">0</span></span>
            <span class="incorrect-count">Sbagliate: <span id="currentIncorrectCount">0</span></span>
        </div>
        <div>
            <button class="btn btn-primary" id="showAnswerBtn">Mostra Risposta</button>
            <button class="btn btn-primary hidden" id="nextBtn">Successiva →</button>
        </div>
    </footer>

    <section class="results hidden" id="results" aria-live="assertive">
        <div class="score-circle" id="scoreCircle">
            <div class="score-inner">
                <div class="score-percentage" id="scorePercentage">0%</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
        </div>
        <h2>Quiz Terminato!</h2>
        <p>Ecco il riepilogo della tua sessione.</p>
        <div class="stats">
            <div class="stat" id="correctStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Corrette (su Totali)</div>
            </div>
            <div class="stat" id="incorrectStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Sbagliate (su Totali)</div>
            </div>
            <div class="stat" id="answeredCorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Corrette / Date</div>
            </div>
            <div class="stat" id="answeredIncorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Sbagliate / Date</div>
            </div>
        </div>
        <button class="btn btn-primary" id="restartBtn">🔄 Ricomincia Quiz</button>
    </section>
</div>

<script>
    const allowedPatterns = [
        'Creator', 'Information Expert', 'Low Coupling', 'High Cohesion', 'Controller',
        'Abstract Factory', 'Singleton', 'Builder',
        'Adapter', 'Composite', 'Decorator', 'Facade',
        'Observer', 'State', 'Strategy', 'Visitor', 'Command', 'Iterator'
    ];
    const allowedTypes = ['Problema-Soluzione', 'UML'];

    const originalQuestions = [
        // GRASP
        { pattern: 'Creator', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Creator?', options: ['Chi deve essere responsabile per la creazione di istanze di una classe?', 'Come mantenere basso l\'accoppiamento tra classi?', 'Come assegnare responsabilità agli oggetti?', 'Come gestire la comunicazione tra oggetti?'], correct: 0, explanation: 'Il pattern Creator affronta il problema di determinare quale classe dovrebbe essere responsabile della creazione di istanze di altre classi.' },
        { pattern: 'Information Expert', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale soluzione propone il pattern Information Expert?', options: ['Centralizzare tutte le informazioni in una classe', 'Assegnare la responsabilità alla classe che ha le informazioni necessarie', 'Creare una classe dedicata per ogni tipo di informazione', 'Utilizzare variabili globali per condividere informazioni'], correct: 1, explanation: 'Information Expert suggerisce di assegnare la responsabilità alla classe che possiede le informazioni necessarie per svolgere quel compito.' },
        { pattern: 'Low Coupling', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale problema affronta il pattern Low Coupling?', options: ['Come aumentare la dipendenza tra classi?', 'Come ridurre l\'impatto dei cambiamenti e aumentare il riuso?', 'Come centralizzare le responsabilità?', 'Come aumentare le prestazioni del sistema?'], correct: 1, explanation: 'Low Coupling mira a ridurre le dipendenze tra classi per minimizzare l\'impatto dei cambiamenti e favorire il riuso.' },
        { pattern: 'High Cohesion', category: 'GRASP', type: 'Problema-Soluzione', question: 'Cosa promuove il pattern High Cohesion?', options: ['Classi con responsabilità molto diverse tra loro', 'Classi con responsabilità strettamente correlate e focalizzate', 'Classi con molte dipendenze esterne', 'Classi con metodi molto lunghi e complessi'], correct: 1, explanation: 'High Cohesion promuove classi con responsabilità strettamente correlate e ben focalizzate, rendendo il codice più comprensibile e mantenibile.' },
        { pattern: 'Controller', category: 'GRASP', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Controller?', options: ['Come gestire l\'interfaccia utente?', 'Chi dovrebbe gestire gli eventi di input del sistema?', 'Come implementare la persistenza dei dati?', 'Come ottimizzare le prestazioni del database?'], correct: 1, explanation: 'Il pattern Controller determina quale oggetto dovrebbe ricevere e coordinare (controllare) gli eventi di input del sistema.' },
        // GoF Creational
        { pattern: 'Singleton', category: 'GoF Creational', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Singleton?', options: ['Come creare famiglie di oggetti correlati?', 'Come garantire che una classe abbia una sola istanza?', 'Come separare la costruzione di oggetti complessi?', 'Come clonare oggetti prototipo?'], correct: 1, explanation: 'Singleton garantisce che una classe abbia una sola istanza e fornisce un punto di accesso globale ad essa.' },
        { pattern: 'Abstract Factory', category: 'GoF Creational', type: 'Problema-Soluzione', question: 'Quale soluzione fornisce il pattern Abstract Factory?', options: ['Crea una singola istanza globale', 'Fornisce un\'interfaccia per creare famiglie di oggetti correlati', 'Separa l\'algoritmo dalla struttura dati', 'Permette di aggiungere nuove operazioni senza modificare le classi'], correct: 1, explanation: 'Abstract Factory fornisce un\'interfaccia per creare famiglie di oggetti correlati o dipendenti senza specificare le loro classi concrete.' },
        // GoF Structural
        { pattern: 'Adapter', category: 'GoF Structural', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Adapter?', options: ['Come comporre oggetti in strutture ad albero?', 'Come permettere a classi con interfacce incompatibili di lavorare insieme?', 'Come aggiungere responsabilità a oggetti dinamicamente?', 'Come condividere efficientemente oggetti simili?'], correct: 1, explanation: 'Adapter permette a classi con interfacce incompatibili di lavorare insieme, agendo come un ponte tra di esse.' },
        { pattern: 'Composite', category: 'GoF Structural', type: 'Problema-Soluzione', question: 'Quale struttura crea il pattern Composite?', options: ['Una catena di oggetti collegati', 'Una struttura ad albero di oggetti', 'Una pila di oggetti', 'Una mappa di oggetti chiave-valore'], correct: 1, explanation: 'Composite permette di comporre oggetti in strutture ad albero per rappresentare gerarchie parte-tutto.' },
        { pattern: 'Decorator', category: 'GoF Structural', type: 'Problema-Soluzione', question: 'Come funziona il pattern Decorator?', options: ['Modifica direttamente la classe originale', 'Avvolge l\'oggetto originale in uno o più wrapper', 'Sostituisce completamente l\'oggetto originale', 'Crea una copia modificata dell\'oggetto'], correct: 1, explanation: 'Decorator permette di aggiungere nuove funzionalità agli oggetti avvolgendoli in wrapper che contengono i nuovi comportamenti.' },
        // GoF Behavioral
        { pattern: 'Observer', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale problema risolve il pattern Observer?', options: ['Come iterare attraverso una collezione?', 'Come notificare automaticamente più oggetti quando cambia lo stato?', 'Come incapsulare algoritmi intercambiabili?', 'Come gestire richieste in una catena di handler?'], correct: 1, explanation: 'Observer definisce una dipendenza uno-a-molti tra oggetti, così quando uno cambia stato, tutti i dipendenti vengono notificati automaticamente.' },
        { pattern: 'State', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale soluzione propone il pattern State?', options: ['Usa un grande switch/if per gestire gli stati', 'Incapsula ogni stato in una classe separata', 'Memorizza tutti gli stati in un array', 'Ignora completamente il concetto di stato'], correct: 1, explanation: 'State permette a un oggetto di cambiare il suo comportamento quando il suo stato interno cambia, incapsulando ogni stato in una classe separata.' },
        { pattern: 'Strategy', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale problema affronta il pattern Strategy?', options: ['Come gestire le notifiche tra oggetti?', 'Come rendere algoritmi intercambiabili in runtime?', 'Come visitare elementi di una struttura complessa?', 'Come gestire stati complessi di un oggetto?'], correct: 1, explanation: 'Strategy definisce una famiglia di algoritmi, li incapsula e li rende intercambiabili durante l\'esecuzione.' },
        { pattern: 'Visitor', category: 'GoF Behavioral', type: 'Problema-Soluzione', question: 'Quale vantaggio offre il pattern Visitor?', options: ['Semplifica la struttura degli oggetti visitati', 'Permette di aggiungere nuove operazioni senza modificare le classi esistenti', 'Riduce il numero di classi nel sistema', 'Migliora le prestazioni dell\'accesso ai dati'], correct: 1, explanation: 'Visitor permette di definire nuove operazioni senza cambiare le classi degli elementi su cui opera, separando algoritmi dalla struttura.' },
        // UML
        { pattern: 'Creator', category: 'GRASP', type: 'UML', question: 'Nel diagramma UML del pattern Creator, quale relazione è tipicamente mostrata?', options: ['Ereditarietà tra creator e prodotto', 'Composizione o aggregazione tra creator e prodotto', 'Associazione bidirezionale', 'Dipendenza circolare'], correct: 1, explanation: 'Il Creator tipicamente ha una relazione di composizione o aggregazione con gli oggetti che crea, mostrata con diamante pieno o vuoto.' },
        { pattern: 'Singleton', category: 'GoF Creational', type: 'UML', question: 'Come è rappresentato il costruttore nel diagramma UML di Singleton?', options: ['Pubblico (+)', 'Privato (-)', 'Protetto (#)', 'Statico (sottolineato)'], correct: 1, explanation: 'Nel Singleton, il costruttore è privato (-) per impedire l\'istanziazione diretta dall\'esterno della classe.' },
        { pattern: 'Observer', category: 'GoF Behavioral', type: 'UML', question: 'Nel pattern Observer, quale interfaccia implementano tipicamente gli observer?', options: ['Subject', 'Observer o Listener', 'ConcreteSubject', 'Publisher'], correct: 1, explanation: 'Gli observer implementano un\'interfaccia Observer (o Listener) che definisce il metodo update() per ricevere notifiche.' },
        { pattern: 'Strategy', category: 'GoF Behavioral', type: 'UML', question: 'Nel diagramma UML di Strategy, il Context ha quale tipo di relazione con Strategy?', options: ['Ereditarietà', 'Composizione', 'Realizzazione', 'Dipendenza semplice'], correct: 3, explanation: 'Il Context utilizza l\'interfaccia Strategy per delegare l\'esecuzione dell\'algoritmo, il che stabilisce una dipendenza semplice. Questo permette al Context di variare l\'algoritmo concreto in modo flessibile.' },
        { pattern: 'Composite', category: 'GoF Structural', type: 'UML', question: 'Nel pattern Composite, come è mostrata la relazione tra Composite e Component?', options: ['Aggregazione semplice', 'Composizione ricorsiva (Composite contiene Component)', 'Ereditarietà multipla', 'Associazione bidirezionale'], correct: 1, explanation: 'Composite eredita da Component e contiene anche una collezione di Component, creando una struttura ricorsiva.' },
        { pattern: 'Decorator', category: 'GoF Structural', type: 'UML', question: 'Nel pattern Decorator, quale caratteristica ha la classe Decorator?', options: ['È finale e non può essere estesa', 'Implementa la stessa interfaccia del componente decorato', 'È statica e contiene solo metodi di utilità', 'È astratta e non può essere istanziata'], correct: 1, explanation: 'Decorator implementa la stessa interfaccia del componente che decora, permettendo di sostituirlo trasparentemente.' },
    ];

    let questions = [];

    const dom = {
        quizContent: document.getElementById('quizContent'),
        progressFill: document.getElementById('progressFill'),
        currentQuestion: document.getElementById('currentQuestion'),
        totalQuestions: document.getElementById('totalQuestions'),
        questionJumpSelect: document.getElementById('questionJump'),
        questionMapContainer: document.getElementById('questionMap'),
        prevBtn: document.getElementById('prevBtn'),
        nextBtn: document.getElementById('nextBtn'),
        showAnswerBtn: document.getElementById('showAnswerBtn'),
        stopBtn: document.getElementById('stopBtn'),
        restartBtn: document.getElementById('restartBtn'),
        results: document.getElementById('results'),
        scorePercentage: document.getElementById('scorePercentage'),
        correctStat: document.querySelector('#correctStat .stat-value'),
        incorrectStat: document.querySelector('#incorrectStat .stat-value'),
        answeredCorrectStat: document.querySelector('#answeredCorrectStat .stat-value'),
        answeredIncorrectStat: document.querySelector('#answeredIncorrectStat .stat-value'),
        scoreCircle: document.getElementById('scoreCircle'),
        progressSection: document.querySelector('.progress-section'),
        controls: document.querySelector('.controls'),
        currentCorrectCount: document.getElementById('currentCorrectCount'),
        currentIncorrectCount: document.getElementById('currentIncorrectCount'),
    };

    let state = {
        currentQuestionIndex: 0,
        userAnswers: [], // Array di oggetti { userAnswer: number | null, correct: boolean | null }
        isShowingAnswer: false,
    };

    function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    function shuffleOptionsAndCorrectIndex(question) {
        const optionsWithOriginalIndex = question.options.map((text, index) => ({ text, originalIndex: index }));
        const shuffledOptionsWithOriginalIndex = shuffleArray(optionsWithOriginalIndex);
        const newOptions = shuffledOptionsWithOriginalIndex.map(opt => opt.text);
        const newCorrectIndex = shuffledOptionsWithOriginalIndex.findIndex(opt => opt.originalIndex === question.correct);
        return { ...question, options: newOptions, correct: newCorrectIndex };
    }

    function getCategoryClass(category) {
        const classMap = {
            'GRASP': 'grasp',
            'GoF Creational': 'gof-creational',
            'GoF Structural': 'gof-structural',
            'GoF Behavioral': 'gof-behavioral',
        };
        return classMap[category] || '';
    }

    function initQuiz() {
        const filtered = originalQuestions.filter(q => allowedPatterns.includes(q.pattern) && allowedTypes.includes(q.type));
        questions = shuffleArray(filtered).map(q => shuffleOptionsAndCorrectIndex(q));

        state.currentQuestionIndex = 0;
        state.userAnswers = new Array(questions.length).fill(null).map(() => ({ userAnswer: null, correct: null }));
        state.isShowingAnswer = false;

        dom.results.classList.add('hidden');
        dom.quizContent.classList.remove('hidden');
        dom.controls.classList.remove('hidden');
        dom.progressSection.classList.remove('hidden');

        if (questions.length === 0) {
            dom.quizContent.innerHTML = "<p style='text-align:center; font-size:1.2rem; color:#6b7280;'>Nessuna domanda disponibile per i criteri selezionati. Prova a modificare i filtri o ad aggiungere più domande.</p>";
            dom.controls.classList.add('hidden');
            dom.progressSection.classList.add('hidden');
            return;
        }
        
        populateQuestionJump();
        populateQuestionMap();

        loadQuestion(); 
        updateProgress();
        updateNavigation();
        updateCurrentStats();
    }

    function loadQuestion() {
        if (questions.length === 0) return;
        state.isShowingAnswer = false;
        const question = questions[state.currentQuestionIndex];
        const userAnswerObj = state.userAnswers[state.currentQuestionIndex];

        dom.quizContent.innerHTML = `
            <div class="question-card" data-question-id="${question.pattern}">
                <div class="question-header">
                    <span class="pattern-category ${getCategoryClass(question.category)}">${question.category} - ${question.pattern}</span>
                    <span class="question-type">${question.type}</span>
                </div>
                <div class="question-text">${question.question}</div>
                <div class="options">
                    ${question.options.map((option, index) => `<div class="option" data-answer="${index}">${option}</div>`).join('')}
                </div>
                <div class="explanation hidden">
                    <h4>Spiegazione:</h4>
                    <p>${question.explanation}</p>
                </div>
            </div>
        `;
        
        const optionsContainer = dom.quizContent.querySelector('.options');
        optionsContainer.addEventListener('click', handleOptionClick);


        if (userAnswerObj.userAnswer !== null) {
            const selectedOption = dom.quizContent.querySelector(`.option[data-answer="${userAnswerObj.userAnswer}"]`);
            if (selectedOption) selectedOption.classList.add('selected');

            if (userAnswerObj.correct !== null) { // Se la risposta è già stata valutata
                state.isShowingAnswer = true;
                const options = dom.quizContent.querySelectorAll('.option');
                options.forEach(opt => opt.classList.add('disabled'));
                const correctOption = dom.quizContent.querySelector(`.option[data-answer="${question.correct}"]`);
                if (correctOption) correctOption.classList.add('correct');
                if (!userAnswerObj.correct && selectedOption) {
                    selectedOption.classList.add('incorrect');
                }
                dom.quizContent.querySelector('.explanation').classList.remove('hidden');
            }
        }

        dom.showAnswerBtn.classList.toggle('hidden', state.isShowingAnswer);
        dom.nextBtn.classList.toggle('hidden', !state.isShowingAnswer);
        
        updateQuestionJumpHighlight();
        updateQuestionMapStyles();
        updateNavigation();
        updateCurrentStats();
    }

    function handleOptionClick(event) {
        const target = event.target;
        if (state.isShowingAnswer || !target.classList.contains('option')) return;

        const optionsContainer = target.closest('.options');
        if (!optionsContainer) return;

        optionsContainer.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
        target.classList.add('selected');

        const answerIndex = parseInt(target.dataset.answer, 10);
        state.userAnswers[state.currentQuestionIndex].userAnswer = answerIndex;
    }

    function showAnswer() {
        if (state.userAnswers[state.currentQuestionIndex].userAnswer === null) {
            alert("Per favore, seleziona una risposta prima.");
            return;
        }

        state.isShowingAnswer = true;
        const question = questions[state.currentQuestionIndex];
        const userAnswerIndex = state.userAnswers[state.currentQuestionIndex].userAnswer;
        const isCorrect = userAnswerIndex === question.correct;
        state.userAnswers[state.currentQuestionIndex].correct = isCorrect;

        loadQuestion(); // Ricarica per mostrare corretto/sbagliato e spiegazione
        updateCurrentStats(); // Aggiorna contatori
        updateQuestionMapStyles(); // Aggiorna la mappa visuale
    }

    function navigate(direction) {
        const newIndex = state.currentQuestionIndex + direction;
        if (newIndex >= 0 && newIndex < questions.length) {
            state.currentQuestionIndex = newIndex;
            loadQuestion();
            updateProgress();
        } else if (newIndex === questions.length) {
            showResults();
        }
    }

    function updateProgress() {
        if (questions.length === 0) return;
        const progress = ((state.currentQuestionIndex + 1) / questions.length) * 100;
        dom.progressFill.style.width = `${progress}%`;
        dom.currentQuestion.textContent = state.currentQuestionIndex + 1;
        dom.totalQuestions.textContent = questions.length;
    }

    function updateNavigation() {
        if (questions.length === 0) {
            dom.prevBtn.disabled = true;
            dom.nextBtn.disabled = true;
            return;
        }
        dom.prevBtn.disabled = state.currentQuestionIndex === 0;
        dom.nextBtn.textContent = state.currentQuestionIndex === questions.length - 1 ? '🏁 Termina Quiz' : 'Successiva →';
    }

    function updateCurrentStats() {
        const correctCount = state.userAnswers.filter(a => a.correct === true).length;
        const incorrectCount = state.userAnswers.filter(a => a.correct === false).length;
        dom.currentCorrectCount.textContent = correctCount;
        dom.currentIncorrectCount.textContent = incorrectCount;
    }

    function showResults() {
        dom.quizContent.classList.add('hidden');
        dom.controls.classList.add('hidden');
        dom.progressSection.classList.add('hidden');
        dom.results.classList.remove('hidden');

        const totalValidQuestions = questions.length; // Usare la lunghezza effettiva delle domande filtrate
        const answeredCount = state.userAnswers.filter(a => a.userAnswer !== null).length;
        const correctTotal = state.userAnswers.filter(a => a.correct === true).length;
        const incorrectTotal = state.userAnswers.filter(a => a.correct === false).length; // Solo quelle valutate come false

        const percentageTotal = totalValidQuestions > 0 ? Math.round((correctTotal / totalValidQuestions) * 100) : 0;

        dom.scorePercentage.textContent = `${percentageTotal}%`;
        dom.correctStat.textContent = correctTotal;
        dom.incorrectStat.textContent = incorrectTotal;
        dom.answeredCorrectStat.textContent = `${correctTotal} / ${answeredCount}`;
        dom.answeredIncorrectStat.textContent = `${incorrectTotal} / ${answeredCount}`;

        const gradientDegrees = (percentageTotal / 100) * 360;
        dom.scoreCircle.style.background = `conic-gradient(#4f46e5 ${gradientDegrees}deg, #e2e8f0 ${gradientDegrees}deg)`;
    }

    // --- Funzioni per Navigazione Avanzata ---
    function populateQuestionJump() {
        if (!dom.questionJumpSelect || questions.length === 0) return;
        dom.questionJumpSelect.innerHTML = '';
        questions.forEach((_, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = index + 1;
            dom.questionJumpSelect.appendChild(option);
        });
        dom.questionJumpSelect.value = state.currentQuestionIndex;
    }

    function updateQuestionJumpHighlight() {
        if (dom.questionJumpSelect) {
            dom.questionJumpSelect.value = state.currentQuestionIndex;
        }
    }

    function handleQuestionJump(event) {
        const newIndex = parseInt(event.target.value, 10);
        if (newIndex >= 0 && newIndex < questions.length && newIndex !== state.currentQuestionIndex) {
            state.currentQuestionIndex = newIndex;
            loadQuestion();
            updateProgress();
        }
    }

    function populateQuestionMap() {
        if (!dom.questionMapContainer || questions.length === 0) return;
        dom.questionMapContainer.innerHTML = '';
        questions.forEach((_, index) => {
            const marker = document.createElement('div');
            marker.classList.add('question-marker');
            marker.dataset.index = index;
            marker.textContent = index + 1;
            marker.addEventListener('click', () => handleQuestionMarkerClick(index));
            dom.questionMapContainer.appendChild(marker);
        });
        updateQuestionMapStyles();
    }

    function handleQuestionMarkerClick(index) {
        if (index >= 0 && index < questions.length && index !== state.currentQuestionIndex) {
            state.currentQuestionIndex = index;
            loadQuestion();
            updateProgress();
        }
    }

    function updateQuestionMapStyles() {
        if (!dom.questionMapContainer || questions.length === 0) return;
        const markers = dom.questionMapContainer.querySelectorAll('.question-marker');
        markers.forEach(marker => {
            const index = parseInt(marker.dataset.index, 10);
            marker.classList.remove('current', 'answered', 'correct', 'incorrect');

            if (index === state.currentQuestionIndex) {
                marker.classList.add('current');
            }

            const answerInfo = state.userAnswers[index];
            if (answerInfo.correct === true) {
                marker.classList.add('correct');
            } else if (answerInfo.correct === false) {
                marker.classList.add('incorrect');
            } else if (answerInfo.userAnswer !== null) {
                marker.classList.add('answered');
            }
        });
    }
    // --- Fine Funzioni Navigazione Avanzata ---

    // Event Listeners
    dom.quizContent.addEventListener('click', handleOptionClick);
    dom.showAnswerBtn.addEventListener('click', showAnswer);
    dom.stopBtn.addEventListener('click', showResults);
    dom.nextBtn.addEventListener('click', () => navigate(1));
    dom.prevBtn.addEventListener('click', () => navigate(-1));
    dom.restartBtn.addEventListener('click', initQuiz);
    if (dom.questionJumpSelect) {
        dom.questionJumpSelect.addEventListener('change', handleQuestionJump);
    }
    
    document.addEventListener('DOMContentLoaded', initQuiz);
</script>
</body>
</html>